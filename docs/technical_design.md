# Spleasy - Technical Design & Architecture

## 1. System Overview

Spleasy is a client-heavy web application focusing on instant interactions. The backend role is primarily data synchronization and persistence. To ensure future extensibility (migrating to Relational DB), we will implement a "Service/Repository" pattern to decouple the UI from the Firestore implementation.

## 2. Technology Stack (Stable / LTS)

*   **Runtime**: Node.js v24.x (Active LTS)
*   **Frontend Framework**: Next.js 16.x (Active LTS, App Router)
*   **Library**: React 19.x (Stable)
*   **Language**: TypeScript 5.9+ (Strict mode)
*   **Styling**: Tailwind CSS v4.x + shadcn/ui (Latest)
*   **Icons**: Lucide React
*   **Infrastructure (MVP)**: Vercel (Hosting) + Firebase Firestore
*   **Time Source**: Helper `server-date.ts` (Next.js Server Time) for createdAt/updatedAt.


## 3. Data Schema (Firestore)

We will use a root-level `groups` collection. Expenses will be a sub-collection of each group to ensure scalability and easy security rules.

### 3.1. Collection: `groups`
Document ID: `groupId` (NanoID or Slug)

```typescript
interface Group {
  id: string;              // Unique Session ID
  name: string;            // "Da Lat Trip"
  normalizeName: string;   // "da lat trip" (for search if needed)
  pin?: string;            // Optional 4-digit PIN
  createdAt: Timestamp;
  updatedAt: Timestamp;
  currency: string;        // Default "VND"
  
  // MEMBER MANAGEMENT (Updated Requirement)
  // We store a centralized list of members to populate dropdowns
  members: Member[];       
}

interface Member {
  id: string;              // UUID generated by client upon join
  displayName: string;     // "Alice"
  joinedAt: Timestamp;
}
```

### 3.2. Sub-collection: `groups/{groupId}/expenses`
Document ID: `expenseId` (Auto-generated)

```typescript
interface Expense {
  id: string;
  groupId: string;
  description: string;     // "Dinner at Market"
  amount: number;          // 500000
  payerId: string;         // Reference to Member.id
  payerName: string;       // Snapshot of name (for history)
  
  // Who is splitting this bill?
  involvedMemberIds: string[]; 

  // Timestamps: Generated by Next.js Server (not Client Browser, not Firestore Timestamp)
  createdAt: number;       // Date.now() from server
  createdBy: string;       // Member.id of who entered it
}
```

## 4. Architecture: Repository Pattern

To minimize vendor lock-in with Firebase, UI components will **not** import Firestore functions directly. Instead, they will use React Hooks that consume a Service Interface.

### 4.1. Directory Structure
```
/src
  /app              # Next.js App Router
  /components       # UI Components
  /services         # Business Logic Interfaces
    /group.ts       # Interface: generic Group operations
    /expense.ts     # Interface: generic Expense operations
    /settlement.ts  # Interface: Debt simplification logic
  /infrastructure   # Concrete Implementations
    /firebase       # Firestore implementation of Services
      /config.ts
      /group-repository.ts
      /expense-repository.ts
    /in-memory        # Logic implementations
      /settlement-service.ts
  /lib              # Utilities (CN, currency formatters)
```

### 4.2. Service Interface (Example)

```typescript
// src/services/group.ts
export interface IGroupService {
  createGroup(name: string, pin?: string): Promise<string>; // Returns ID
  getGroup(id: string): Promise<Group | null>;
  joinGroup(groupId: string, member: Member): Promise<void>;
  leaveGroup(groupId: string): void; // Clears local storage/session for this group
  subscribeToGroup(groupId: string, callback: (group: Group) => void): () => void; // Unsubscribe
}
```

### 4.3. Usage in Components

```tsx
// src/hooks/useGroup.ts
export function useGroup(groupId: string) {
  // Uses the concrete Firebase implementation internally
  // Easy to swap with usePostgresGroup() later
  const [group, setGroup] = useState<Group | null>(null);
  
  useEffect(() => {
    const unsubscribe = firebaseGroupService.subscribeToGroup(groupId, setGroup);
    return () => unsubscribe();
  }, [groupId]);

  return { group };
}
```

## 5. Security Rules (Firestore)

Since we are using anonymous auth (or no auth for MVP), rules will be relatively open but scoped to the generic idea of knowing the Group ID (Capability URL pattern).

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /groups/{groupId} {
      allow read, write: if true; // Security relies on knowing the randomized groupId
      
      match /expenses/{expenseId} {
        allow read, write: if true;
      }
    }
  }
}
```
*Note: For a stricter MVP, we can implement basic "Anonymous Auth" via Firebase Authentication to rate-limit writes.*

## 6. API / Server Actions (Mental Model)

Since we are using Firestore Client SDK for real-time updates, we do not strictly need Next.js API Routes for data fetching. However, we can use **Server Actions** for specific write operations if we want to move logic to the server later.

For MVP: **Client-side SDK** is preferred for the "Instant" real-time feedback loop.

## 7. Migration Strategy (Future)

To migrate to SQL (Drizzle ORM) later:
1.  Create `src/infrastructure/postgres/group-repository.ts`.
2.  Implement `IGroupService` using Drizzle calls.
3.  Update the `useGroup` hook to use the new implementation (likely switching from `subscribe` to `SWR` or `TanStack Query` polling/sockets).
4.  The UI components remain untouched.
